/**
 *   _ _ _           _               
 *  | ( ) |__   __ _| | __ _ ___ ___ 
 *  | | | '_ \ / _` | |/ _` / __/ __|
 *  | | | |_) | (_| | | (_| \__ \__ \
 *  |_|_|_.__/ \__,_|_|\__,_|___/___/
 *                                      
 *  Copyright (C) 2020 wsiegenthaler
 *  
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 **/

#ifndef ALASS_H
#define ALASS_H

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 *
 * Receives audio samples to be processed for voice-activity and used as reference
 * by the synchronization process
 *
 */
typedef struct AlassAudioSink AlassAudioSink;

/**
 *
 * Options governing the synchronization process
 *
 * Most of these options are passed directly to `alass`. See the official `alass` repository for
 * details: https://github.com/kaegi/alass
 *
 * * `interval`: The smallest unit of time recognized by `alass`. Smaller numbers make the alignment
 *    more accurate, larger numbers make alignment faster. (millis)
 *
 * * `split_mode`: When true, `alass` will attempt alignment assuming the presence of commercial breaks
 *    or added/removed scenes. Disabling `split_mode` can make syncing faster but will only correct
 *    subtitles whose misalignment is the result of a constant shift.
 *
 * * `split_penalty`: Determines how eager the algorithm is to avoid splitting of the subtitles. A
 *    value of 1000 means that all lines will be shifted by the same offset, while 0.01 will produce
 *    MANY segments with different offsets. Values from 1 to 20 are the most reasonable.
 *
 * * `speed_optimization`: Greatly speeds up synchronization by sacrificing accuracy.
 *
 * * `framerate_correction`: Whether to attempt correction of mismatched framerates.
 *
 */
typedef struct AlassSyncOptions AlassSyncOptions;

/**
 *
 * `TimeSpan` buffer to be used as reference by the synchronization process
 *
 * May be generated from an `AudioSink` that's been processed for voice-
 * activity, extracted from a subtitle file whose timing is known to be good,
 * or populated manually by some other process (e.g. extracing embedded subs
 * from video file). `TimeSpans` also provides functionality for reading and
 * writing raw timespan data to/from disk which is useful for caching.
 *
 */
typedef struct AlassTimeSpans AlassTimeSpans;

/**
 *
 * Voice activity as computed by `webrtc-vad`
 *
 */
typedef struct AlassVoiceActivity AlassVoiceActivity;

typedef uint32_t AlassResultCode;

typedef uintptr_t AlassLogLevel;

extern const AlassResultCode ALASS_FILE_DOES_NOT_EXIST;

extern const AlassResultCode ALASS_INTERNAL_ERROR;

extern const AlassResultCode ALASS_INVALID_PARAMS;

extern const AlassResultCode ALASS_LOG_ALREADY_CONFIGURED;

extern const AlassLogLevel ALASS_LOG_DEBUG;

extern const AlassLogLevel ALASS_LOG_ERROR;

extern const AlassLogLevel ALASS_LOG_INFO;

extern const AlassLogLevel ALASS_LOG_NONE;

extern const AlassLogLevel ALASS_LOG_TRACE;

extern const AlassLogLevel ALASS_LOG_WARN;

extern const AlassResultCode ALASS_PARSE_ERROR;

extern const AlassResultCode ALASS_PERMISSION_DENIED;

extern const AlassResultCode ALASS_READ_ERROR;

extern const AlassResultCode ALASS_SERIALIZE_ERROR;

extern const AlassResultCode ALASS_SINK_CLOSED;

extern const AlassResultCode ALASS_SUCCESS;

extern const AlassResultCode ALASS_UNSUPPORTED_FORMAT;

extern const AlassResultCode ALASS_WRITE_ERROR;

/**
 *
 * Closes a given audio sink. Once a sink is closed it can no longer receive additional samples.
 *
 */
void alass_audio_sink_close(AlassAudioSink *sink);

/**
 *
 * Deallocates an audio sink.
 *
 */
void alass_audio_sink_free(AlassAudioSink *sink);

/**
 *
 * Allocates a new audio sink ready to receive audio samples.
 *
 */
AlassAudioSink *alass_audio_sink_new(void);

/**
 *
 * Send audio samples to given sink. Samples should be 8kHz 16-bit signed
 * little-endian mono.
 *
 */
AlassResultCode alass_audio_sink_send(AlassAudioSink *sink, uint8_t *samples, int64_t sample_cnt);

/**
 *
 * Determines whether the given subtitle is able to be synced
 *
 * Support is indicated by either `ALASS_SUCCESS`, `ALASS_UNSUPPORTED_FORMAT`,
 * or a more specific result code if a determination could not be made.
 *
 */
AlassResultCode alass_format_is_supported(const char *sub_path);

/**
 *
 * Configure logging
 *
 * Logging can only be configured once per application; subsequent calls will
 * fail with `ALASS_LOG_ALREADY_CONFIGURED`.
 *
 * Also note that `stderr_level` takes precedence over `stdout_level`, so any
 * overlap will only go to `stderr`. For example, if `stdout` is `ALASS_LOG_DEBUG`
 * and `stderr` is `ALASS_LOG_WARN`, debug and info events will go to `stdout`
 * and warn and error to `stderr`).
 *
 * * `stdout_level`: Threshold of log events that should be written to `stdout`.
 * * `stderr_level`: Threshold of log events that should be written to `stderr`.
 * * `log_file_level`: Threshold of log events that should be written to log file.
 * * `log_file`: Path of the file to recieve log events (or null if not applicable).
 *
 */
AlassResultCode alass_log_config(AlassLogLevel stdout_level,
                                 AlassLogLevel stderr_level,
                                 AlassLogLevel log_file_level,
                                 const char *log_file);

/**
 *
 * Deallocates options instance
 *
 */
void alass_options_free(AlassSyncOptions *options);

/**
 *
 * Logs the values of the given options instance (useful for debugging)
 *
 */
void alass_options_log(AlassSyncOptions *options);

/**
 *
 * Creates a new options instance initialized to default values
 *
 */
AlassSyncOptions *alass_options_new(void);

/**
 *
 * Whether attempt correction of mismatched framerates
 *
 * Currently the voice-activity detection isn't accurate enough to support
 * this feature and often results in framerate misdetection. It is recommended
 * to only enable framerate correction when using subtitle generated reference
 * spans. (default `false`)
 *
 */
AlassResultCode alass_options_set_framerate_correction(AlassSyncOptions *options, bool value);

/**
 *
 * Sets the `alass` "interval" parameter
 *
 * This value represents the smallest recognized unit of time. Smaller numbers make
 * the alignment more accurate, greater numbers make aligning faster. (default `60`)
 *
 */
AlassResultCode alass_options_set_interval(AlassSyncOptions *options, int64_t value);

/**
 *
 * Sets the `alass` "speed_optimization" parameter
 *
 * Greatly speeds up synchronization by sacrificing some accuracy. Set to zero to
 * disable speed optimization. (default `1.0`)
 *
 */
AlassResultCode alass_options_set_speed_optimization(AlassSyncOptions *options, double value);

/**
 *
 * Sets the `alass` "split_mode" parameter
 *
 * When true `alass` will attempt alignment assuming the presence of commercial breaks or
 * added/removed scenes. Disabling `split_mode` can make syncing faster but will only correct
 * subtitles whose misalignment is the result of a constant shift. (default `true`)
 *
 */
AlassResultCode alass_options_set_split_mode(AlassSyncOptions *options, bool value);

/**
 *
 * The `alass` "split_penalty" parameter
 *
 * Determines how eager the algorithm is to avoid splitting of the subtitles. A value of 1000
 * means that all lines will be shifted by the same offset, while 0.01 will produce MANY
 * segments with different offsets. Values from 1 to 20 are the most useful subtitles by a
 * constant amount. (default `7.0`)
 *
 */
AlassResultCode alass_options_set_split_penalty(AlassSyncOptions *options, double value);

/**
 *
 * Performs `alass` subtitle synchronization.
 *
 * * `sub_path_in`: Path to the incorrect subtitle file.
 *
 * * `sub_path_out`: Path to which the synchronized subtitle file shall
 *    be written (must include filename).
 *
 * * `ref_spans`: Reference timespans to use for alignment.
 *
 * * `ref_fps`: Framerate of the reference video file (used for framerate correction).
 *
 * * `sub_encoding`: The IANA charset encoding of the subtitle file. If 'auto' is
 *    given (or if not specified), an attempt is made to guess the correct encoding
 *    based on the contents of the file.
 *
 * * `options`: Parameters governing various aspects of the synchronization process. See
 *    `SyncOptions` or `alass` documentation for details.
 *
 */
AlassResultCode alass_sync(const char *sub_path_in,
                           const char *sub_path_out,
                           AlassTimeSpans *ref_spans,
                           double ref_fps,
                           const char *sub_encoding,
                           AlassSyncOptions *options);

/**
 *
 * Computes timespans given detected voice-activity.
 *
 */
AlassTimeSpans *alass_timespans_compute(AlassVoiceActivity *activity);

/**
 *
 * Deallocates timespans buffer.
 *
 */
void alass_timespans_free(AlassTimeSpans *spans);

/**
 *
 * Loads cached timespans from disk (see `alass_timespans_save_raw()`). Returns
 * null if no file exists at the given path.
 *
 */
AlassTimeSpans *alass_timespans_load_raw(const char *filename);

/**
 *
 * Loads timespans from subtitle file. Returns null if no file exists at the given path.
 *
 */
AlassTimeSpans *alass_timespans_load_subtitle(const char *filename, const char *sub_encoding);

/**
 *
 * Creates a new timespans buffer ready to accept data (see `alass_timespans_push()`).
 *
 */
AlassTimeSpans *alass_timespans_new(void);

/**
 *
 * Appends timespan to buffer. Start and end times are in milliseconds.
 *
 */
AlassResultCode alass_timespans_push(AlassTimeSpans *spans, int64_t start_time, int64_t end_time);

/**
 *
 * Saves timespans to disk with the given `filename` (see `alass_timespans_load_raw()`).
 *
 */
AlassResultCode alass_timespans_save_raw(AlassTimeSpans *spans, const char *filename);

/**
 *
 * [EXPERIMENTAL] Cleans voice-activity data
 *
 * This operation successively employs mathematical morphological 'erosion'
 * and 'dilation` operators to clean the output of the voice-activity detector.
 * The result is a clone of the original voice activity buffer having
 * cleaner/fewer timespans.
 *
 * The `opening_radius` and `closing_radius` parameters represent the kernel radii
 * of the mathematical morphological operators. Each radius determines a window
 * of size `(2r+1)*CHUNK_MILLIS` milliseconds. Any errant spans smaller than this
 * window will be removed and any gaps larger than this window will be filled.
 *
 */
AlassVoiceActivity *alass_voice_activity_clean(AlassVoiceActivity *activity,
                                               uintptr_t opening_radius,
                                               uintptr_t closing_radius);

/**
 *
 * Computes voice activity given an audio sink containing sample data.
 *
 */
AlassVoiceActivity *alass_voice_activity_compute(AlassAudioSink *sink);

/**
 *
 * Deallocates voice activity buffer.
 *
 */
void alass_voice_activity_free(AlassVoiceActivity *activity);

#endif /* ALASS_H */
